<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Mensajes - Flick</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
  <style>
    /* Basic styles from home.html will be copied here in a later step */
    /* For now, include some very basic body styling for structure */
    * { 
      box-sizing: border-box; 
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif; 
      margin: 0; 
      padding: 0; 
    }
    body { 
      background: linear-gradient(135deg, #0a0a0a 0%, #1a0a2e 25%, #16213e 50%, #0f3460 75%, #0a0a0a 100%);
      background-attachment: fixed;
      color: #e0e6ed;
      padding: 20px;
      min-height: 100vh;
      position: relative;
      overflow-x: hidden;
    }
    body::before { /* Radiant light effects */
      content: '';
      position: fixed;
      top: -50%; left: -50%;
      width: 200%; height: 200%;
      background: radial-gradient(circle at 30% 20%, rgba(99, 102, 241, 0.1) 0%, transparent 50%),
                  radial-gradient(circle at 70% 80%, rgba(168, 85, 247, 0.1) 0%, transparent 50%),
                  radial-gradient(circle at 50% 50%, rgba(59, 130, 246, 0.05) 0%, transparent 50%);
      animation: floating 20s ease-in-out infinite;
      pointer-events: none;
      z-index: -1;
    }
    @keyframes floating { 0%, 100% { transform: rotate(0deg) scale(1); } 50% { transform: rotate(180deg) scale(1.1); } }

    .header { /* Copied from home.html for consistency */
      display: flex; 
      justify-content: space-between; 
      align-items: center;
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.2) 0%, rgba(168, 85, 247, 0.2) 100%);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: #fff; 
      padding: 20px; 
      border-radius: 20px;
      margin-bottom: 30px; 
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      position: relative;
      overflow: hidden;
    }
    .header::before { /* Header animation */
      content: '';
      position: absolute;
      top: -50%; left: -50%;
      width: 200%; height: 200%;
      background: conic-gradient(from 0deg, transparent 0deg, rgba(99, 102, 241, 0.3) 90deg, transparent 180deg);
      animation: rotate 4s linear infinite;
      pointer-events: none;
    }
    @keyframes rotate { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    .header h2 { position: relative; z-index: 1; font-weight: 700; font-size: 1.8rem; background: linear-gradient(135deg, #60a5fa, #a78bfa, #f472b6); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
    .header-actions {
      display: flex;
      /* flex-direction: row; */ /* Default, so can be omitted */
      gap: 12px; /* Restore original/desired gap for horizontal layout */
      position: relative;
      z-index: 1;
      /* align-items: flex-end; */ /* Removed */
    }
    .logout-btn, .profile-btn, .home-btn, .messages-btn { /* Added .home-btn, .messages-btn */
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.8), rgba(168, 85, 247, 0.8));
      color: #fff; border: none; padding: 12px 20px; font-weight: 600; border-radius: 12px; cursor: pointer; 
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); position: relative; overflow: hidden;
    }
    .logout-btn::before, .profile-btn::before, .home-btn::before, .messages-btn::before {
      content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
      transition: left 0.5s;
    }
    .logout-btn:hover::before, .profile-btn:hover::before, .home-btn:hover::before, .messages-btn:hover::before { left: 100%; }
    .logout-btn:hover, .profile-btn:hover, .home-btn:hover, .messages-btn:hover { transform: translateY(-2px); box-shadow: 0 8px 25px rgba(99, 102, 241, 0.4); }

    .content { display: grid; grid-template-columns: 1fr 2fr; gap: 30px; }
    .panel { 
      background: rgba(255, 255, 255, 0.05); backdrop-filter: blur(20px); border: 1px solid rgba(255, 255, 255, 0.1);
      padding: 24px; border-radius: 20px; margin-bottom: 20px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    .panel:hover { transform: translateY(-4px); box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4); border-color: rgba(99, 102, 241, 0.3); }
    h3 { margin-bottom: 16px; color: #60a5fa; border-bottom: 2px solid rgba(99, 102, 241, 0.3); padding-bottom: 8px; font-weight: 600; font-size: 1.1rem; }
    .user-list { list-style: none; margin-top: 12px; }
    .user-list li { 
      padding: 12px 16px; border-bottom: 1px solid rgba(255, 255, 255, 0.1); cursor: pointer; 
      border-radius: 8px; margin-bottom: 4px; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    .user-list li:hover { background: rgba(99, 102, 241, 0.2); transform: translateX(8px); }
    
    /* Responsive Design */
    @media (max-width: 768px) { 
      .content { grid-template-columns: 1fr; } 
      .header-actions { 
        flex-direction: column; 
        gap: 8px; 
      } 
      .header h2 { font-size: 1.5rem; } 
      body { padding: 15px; } 
    }
    
    /* Styles for chat elements will be moved/added here later */
    /* Copied from previous step for chat elements, to be refined in styling step */
    .chat-messages-area { height: 400px; /* Adjusted height */ overflow-y: auto; padding: 15px; margin-bottom: 15px; border-radius: 12px; background: rgba(0, 0, 0, 0.25); border: 1px solid rgba(255, 255, 255, 0.08); }
    .chat-input-area { display: flex; gap: 10px; align-items: flex-end; }
    #chatMessageInput { flex-grow: 1; min-height: 44px; resize: none; /* Assuming general input styles are present */ width: 100%; padding: 14px 16px; margin-top: 12px; border: 2px solid rgba(255, 255, 255, 0.1); border-radius: 12px; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); resize: vertical; background: rgba(255, 255, 255, 0.05); color: #e0e6ed; font-size: 14px;}
    #chatMessageInput:focus { border-color: #60a5fa; outline: none; box-shadow: 0 0 20px rgba(96, 165, 250, 0.3); background: rgba(255, 255, 255, 0.08); }
    #chatMessageInput::placeholder { color: #9ca3af; }
    .btn { margin: 6px; padding: 10px 18px; background: linear-gradient(135deg, #60a5fa, #3b82f6); border: none; color: #fff; border-radius: 10px; cursor: pointer; font-weight: 600; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); font-size: 13px; position: relative; overflow: hidden; }
    .btn::before { content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%; background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent); transition: left 0.6s; }
    .btn:hover::before { left: 100%; }
    .btn:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(59, 130, 246, 0.4); }
    #sendChatMessageBtn { height: 44px; min-width: 90px; margin-top:12px; /* Align with textarea's margin-top */ }
    /* Scrollbar and other common styles will be added in the styling step */
    ::-webkit-scrollbar { width: 8px; }
    ::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.1); border-radius: 10px; }
    ::-webkit-scrollbar-thumb { background: linear-gradient(135deg, #60a5fa, #3b82f6); border-radius: 10px; }
    ::-webkit-scrollbar-thumb:hover { background: linear-gradient(135deg, #3b82f6, #2563eb); }
    .updating-indicator { position: fixed; top: 20px; right: 20px; background: linear-gradient(135deg, rgba(59, 130, 246, 0.9), rgba(99, 102, 241, 0.9)); backdrop-filter: blur(20px); color: white; padding: 12px 20px; border-radius: 20px; font-size: 13px; font-weight: 500; opacity: 0; transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1); z-index: 1000; border: 1px solid rgba(255, 255, 255, 0.2); }
    .updating-indicator.show { opacity: 1; transform: translateY(0); }
    #logoutModal { display: none; position: fixed; z-index: 1001; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); backdrop-filter: blur(5px); }
    .logout-modal-content { background: linear-gradient(135deg, #1a0a2e, #16213e); margin: 15% auto; padding: 30px; border: 1px solid rgba(255, 255, 255, 0.1); width: 80%; max-width: 450px; text-align: center; border-radius: 20px; color: #e0e6ed; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4); animation: fadeInModal 0.3s ease-out; }
    @keyframes fadeInModal { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
    .logout-modal-content p { font-size: 1.2em; margin-bottom: 25px; line-height: 1.6; }
    .logout-modal-content .btn { margin: 5px; padding: 12px 25px; font-size: 14px; }
    #confirmLogoutBtn { background: linear-gradient(135deg, #ef4444, #dc2626); } #confirmLogoutBtn:hover { box-shadow: 0 6px 20px rgba(239, 68, 68, 0.5); }
    #cancelLogoutBtn { background: linear-gradient(135deg, #60a5fa, #3b82f6); } #cancelLogoutBtn:hover { box-shadow: 0 6px 20px rgba(59, 130, 246, 0.5); }

    /* Chat Bubble Styling */
    .chat-messages-area {
      /* display: flex; */ /* Existing style has overflow-y, flex might conflict if not careful. Keep existing for now, add gap */
      /* flex-direction: column; */
      gap: 10px; /* Space between messages - this is new and useful */
    }

    .chat-message {
      display: flex;
      max-width: 70%; /* Bubbles shouldn't be full width */
      align-items: flex-end; /* Align timestamp and content nicely */
      margin-bottom: 10px; /* Added to ensure gap is respected if flex gap isn't fully effective due to other styles */
    }

    .chat-message.sent {
      align-self: flex-end; /* Sent messages to the right */
      flex-direction: row-reverse; /* Makes bubble appear before timestamp for sent */
      margin-left: auto; /* Ensure it aligns to the right */
    }

    .chat-message.received {
      align-self: flex-start; /* Received messages to the left */
      flex-direction: row;
      margin-right: auto; /* Ensure it aligns to the left */
    }

    .chat-message-bubble {
      padding: 10px 15px;
      border-radius: 18px; /* Rounded corners for bubble */
      position: relative; /* For potential future use with ::before/::after for tails */
      word-wrap: break-word; /* Ensure long words don't break layout */
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }

    .chat-message.sent .chat-message-bubble {
      background: linear-gradient(135deg, #007bff, #0056b3); /* Blue gradient for sent messages */
      color: white;
      border-top-right-radius: 5px; /* Different corner for tail effect */
    }

    .chat-message.received .chat-message-bubble {
      background: linear-gradient(135deg, #6c757d, #495057); /* Grey gradient for received messages */
      color: white;
      border-top-left-radius: 5px; /* Different corner for tail effect */
    }

    .message-sender {
      display: block;
      font-size: 0.8em;
      font-weight: bold;
      margin-bottom: 5px;
      /* color: rgba(255, 255, 255, 0.8); */ /* Color is white from bubble, this could make it less readable */
    }
    
    .chat-message.sent .message-sender {
      text-align: right; /* Align sender name to the right for sent messages */
       /* display: none; */ /* Hiding sender name for current user's messages */
    }
    /* For received messages, sender name is already left-aligned by default block display */

    .message-content {
      font-size: 1em;
      line-height: 1.4;
    }

    .message-timestamp {
      font-size: 0.75em;
      /* color: rgba(255, 255, 255, 0.6); */ /* Will inherit color from bubble, adjust if needed */
      color: #e0e6ed; /* A slightly lighter color than bubble text for subtlety if bubble is dark */
      opacity: 0.8;
      margin-top: 5px;
      display: block; /* Ensure it takes its own line or space */
    }
    
    .chat-message.sent .message-timestamp {
      text-align: right;
      margin-left: 8px; /* Space between bubble and timestamp */
      margin-right: 0;
    }

    .chat-message.received .message-timestamp {
      text-align: left;
      margin-right: 8px; /* Space between bubble and timestamp */
      margin-left: 0;
    }
    
    /* Ensure sender name is not shown for current user's messages for a cleaner look */
    /* Decided to hide it for .sent messages as it's usually implied */
    .chat-message.sent .message-sender {
        display: none; 
    }

    /* Clearing any float issues if floats were used (not used here, but good practice) */
    /* .chat-messages-area::after {
      content: "";
      clear: both;
      display: table;
    } */
    /* The flex model used for .chat-message makes this unnecessary.
       The existing .chat-messages-area is a block with overflow-y: auto, so children layout within it.
       If .chat-message itself were floated, then this would be relevant for .chat-messages-area.
    */

    /* Archive Button and Modal Styling */
    .archive-chat-btn {
      background: #dc3545; /* Red background */
      color: white;
      padding: 3px 8px; 
      font-size: 0.7em; 
      margin-left: 5px;
      border-radius: 5px;
      border: none;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }
    .archive-chat-btn:hover {
      background: #c82333; /* Darker red on hover */
    }

    #archiveChatModal { 
      display: none; 
      position: fixed; 
      z-index: 1001; 
      left: 0; 
      top: 0; 
      width: 100%; 
      height: 100%; 
      overflow: auto; 
      background-color: rgba(0,0,0,0.6); 
      backdrop-filter: blur(5px); 
    }
    .archive-modal-content { 
      background: linear-gradient(135deg, #1a0a2e, #16213e); 
      margin: 15% auto; 
      padding: 30px; 
      border: 1px solid rgba(255, 255, 255, 0.1); 
      width: 80%; 
      max-width: 500px; /* Slightly wider for the longer text */
      text-align: center; 
      border-radius: 20px; 
      color: #e0e6ed; 
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4); 
      animation: fadeInModal 0.3s ease-out; /* Re-use existing animation */
    }
    .archive-modal-content p { 
      font-size: 1.1em; /* Slightly smaller than logout for more text */
      margin-bottom: 25px; 
      line-height: 1.6; 
    }
    .archive-modal-content .btn { /* General button style within this modal */
      margin: 5px; 
      padding: 12px 25px; 
      font-size: 14px; 
    }
    #confirmArchiveBtn { 
      background: linear-gradient(135deg, #ef4444, #dc2626); /* Red for confirm */
    } 
    #confirmArchiveBtn:hover { 
      box-shadow: 0 6px 20px rgba(239, 68, 68, 0.5); 
    }
    #cancelArchiveBtn { 
      background: linear-gradient(135deg, #60a5fa, #3b82f6); /* Blue for cancel */
    } 
    #cancelArchiveBtn:hover { 
      box-shadow: 0 6px 20px rgba(59, 130, 246, 0.5); 
    }

  </style>
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/toastify-js/src/toastify.min.css">
</head>
<body>
  <div class="updating-indicator" id="updateIndicator">Actualizando...</div>

  <div class="header">
    <h2>Mensajes</h2> <!-- Title changed to Mensajes -->
    <div class="header-actions">
      <button id="homeBtn" class="home-btn">Inicio</button> <!-- Home button -->
      <button id="profileBtn" class="profile-btn">Mi Perfil</button>
      <button id="logoutBtn" class="logout-btn">Cerrar Sesión</button>
    </div>
  </div>

  <div class="content">
    <!-- First column for requests and conversations list -->
    <div id="conversationsColumn">
        <div class="panel" id="solicitudesPanel">
            <h3>Solicitudes de Mensajes Pendientes</h3>
            <ul id="listaSolicitudesMensajes" class="user-list">
                <!-- Request items will be populated here by JS -->
            </ul>
        </div>

        <!-- Reactivation Requests Panel REMOVED -->

      <div class="panel" id="conversacionesPanel">
        <h3>Conversaciones</h3>
        <ul id="listaConversaciones" class="user-list">
          <!-- Conversation items will be populated here by JS -->
          <!-- Example: <li>Usuario Ejemplo (Último: Hola...)</li> -->
        </ul>
      </div>
    </div>

    <!-- Second column for the chat window -->
    <div id="chatColumn">
      <div class="panel" id="chatPanel" style="display: none;"> <!-- Initially hidden or shows a placeholder -->
        <h3>Chat con <span id="chatUserName">Usuario</span></h3>
        <div id="chatMessages" class="chat-messages-area">
          <p id="chatPlaceholder" style="text-align:center; color:#9ca3af; padding-top: 50px;">Selecciona una conversación para empezar a chatear.</p>
        </div>
        <div class="chat-input-area">
          <textarea id="chatMessageInput" rows="2" placeholder="Escribe un mensaje..."></textarea>
          <button id="sendChatMessageBtn" class="btn">Enviar</button>
        </div>
      </div>
    </div>
  </div>

  <div id="logoutModal">
    <div class="logout-modal-content">
      <p>¿Estás seguro que quieres cerrar sesión?</p>
      <button id="confirmLogoutBtn" class="btn">Confirmar</button>
      <button id="cancelLogoutBtn" class="btn">Cancelar</button>
    </div>
  </div>

  <!-- Archive Chat Confirmation Modal is REMOVED -->

  <script>
    // Global app state
    const app = {
      user: null,
      currentChatPartnerId: null,
      currentChatPartnerName: null,
      chatPollInterval: null,
      solicitudesPollInterval: null, // Add this line
      // archivingChatPartnerId: null, // Obsolete
      // currentChatArchivalStatus: null, // Obsolete
    };

    // DOM Elements 
    let listaConversacionesEl, chatPanelEl, chatUserNameEl, chatMessagesEl, chatMessageInputEl, sendChatMessageBtnEl, chatPlaceholderEl;
    let listaSolicitudesMensajesEl; 
    // let listaSolicitudesReactivacionEl; // Fully Removed
    let homeBtnEl, profileBtnEl, logoutBtnEl, logoutModal, confirmLogoutBtn, cancelLogoutBtn, updateIndicator;
    // archiveChatModal, confirmArchiveBtn, cancelArchiveBtn are Obsolete

    // [FROM HOME.HTML] Full 'utils' object definition:
    const utils = {
     debounce(func, wait) {
       let timeout;
       return (...args) => {
         clearTimeout(timeout);
         timeout = setTimeout(() => func(...args), wait);
       };
     },
     showMessage(msg, type = 'info') {
       // Assumes showNotification is available globally from notifications.js
       if (typeof showNotification === 'function') {
         showNotification(msg, type);
       } else {
         console.warn('showNotification not available, logging to console:', msg);
       }
     },
     async apiCall(url, options = {}) {
       try {
         const response = await fetch(url, {
           headers: { 'Content-Type': 'application/json' },
           ...options
         });
         if (!response.ok) {
           const errorData = await response.text(); // Try to get more error info
           console.error('API Error Data:', errorData);
           throw new Error(`HTTP ${response.status}: ${response.statusText}`);
         }
         // Check if response is JSON before parsing
         const contentType = response.headers.get("content-type");
         if (contentType && contentType.indexOf("application/json") !== -1) {
            return response.json();
         } else {
            return response.text(); // Return as text if not JSON (e.g. for logout)
         }
       } catch (error) {
         console.error('API Call Error:', error);
         // utils.showMessage(`Error en la solicitud: ${error.message}`, 'error'); // Avoid infinite loop if showMessage calls apiCall
         throw error;
       }
     },
     showUpdateIndicator() {
       if(updateIndicator) { // updateIndicator should be assigned in init
           updateIndicator.classList.add('show');
           setTimeout(() => updateIndicator.classList.remove('show'), 1000);
       }
     }
   };

   // [FROM HOME.HTML] Full 'auth' object definition:
   const auth = {
     async checkSession() {
       try {
         const response = await fetch('/usuarios/session');
         if (response.ok) {
           app.user = await response.json();
           return true;
         }
         this.redirectToLogin();
         return false;
       } catch (error) {
         console.error('Session check error:', error);
         utils.showMessage('Error de conexión, redirigiendo al login.', 'error');
         this.redirectToLogin();
         return false;
       }
     },
     async logout() {
       try {
         await utils.apiCall('/usuarios/logout', { method: 'POST' });
         utils.showMessage('Sesión cerrada correctamente', 'success');
       } catch (error) {
         // Error already logged by apiCall, utils.showMessage might have been called too.
         // utils.showMessage('Error al cerrar sesión en servidor', 'warning');
       } finally {
         this.clearSession(); // Perform client-side cleanup regardless of server response
         this.redirectToLogin();
       }
     },
     clearSession() {
       app.user = null;
       app.currentChatPartnerId = null;
       app.currentChatPartnerName = null;
       if (chat && typeof chat.stopPollingMessages === 'function') { // Ensure chat exists and has the method
            chat.stopPollingMessages();
       } else if (app.chatPollInterval) { // Fallback if chat object isn't fully initialized
            clearInterval(app.chatPollInterval);
            app.chatPollInterval = null;
       }
       chat.stopPollingSolicitudes(); // Add this line
       
       try {
         document.cookie.split(";").forEach(cookie => {
           const eqPos = cookie.indexOf("=");
           const name = eqPos > -1 ? cookie.substr(0, eqPos).trim() : cookie.trim();
           if (name) { document.cookie = name + "=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/"; }
         });
       } catch (cookieError) { console.log('Cookie cleanup not needed or failed'); }

       if(chatPanelEl) chatPanelEl.style.display = 'none';
       if(listaConversacionesEl) listaConversacionesEl.innerHTML = '';
       if(listaSolicitudesMensajesEl) listaSolicitudesMensajesEl.innerHTML = ''; // Clear message requests
       if(chatMessagesEl) chatMessagesEl.innerHTML = '';
       if(chatUserNameEl) chatUserNameEl.textContent = 'Usuario';
       if(chatPlaceholderEl) chatPlaceholderEl.style.display = 'block';
     },
     redirectToLogin() {
       // Add a slight delay to allow any messages (like logout success) to be seen
       setTimeout(() => { window.location.href = 'index.html'; }, 500);
     }
   };

   // Functions for Message Requests
   async function cargarSolicitudesMensajes(silent = false) { // Modified signature
    if (!app.user || !listaSolicitudesMensajesEl) return;
    try {
      if (!silent) { // Conditional call
        utils.showUpdateIndicator();
      }
      const solicitudes = await utils.apiCall('/solicitudesMensajes');
      listaSolicitudesMensajesEl.innerHTML = '';
      if (solicitudes.length === 0) {
        listaSolicitudesMensajesEl.innerHTML = '<li style="text-align:center; color:#888e9e !important; font-style: italic !important; padding: 15px !important; background: transparent !important; border: none !important;">No tienes solicitudes pendientes.</li>';
        return;
      }
      solicitudes.forEach(solicitud => {
        const li = document.createElement('li');
        li.style.padding = '10px'; // Adjust padding for buttons
        li.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
            <div style="flex-grow: 1;">
              <strong style="color: #e0e6ed;">De: ${solicitud.emisor.nombre}</strong>
              <small style="display:block; color: #9ca3af; font-size:0.9em; margin-top: 4px;">
                "${solicitud.contenido.substring(0, 30)}${solicitud.contenido.length > 30 ? '...' : ''}"
              </small>
            </div>
            <div style="flex-shrink: 0; display: flex; gap: 5px;">
              <button class="btn btn-sm" onclick="aprobarSolicitud('${solicitud._id}')" style="background: linear-gradient(135deg, #28a745, #218838); padding: 5px 10px; font-size: 0.8em;">Aprobar</button>
              <button class="btn btn-sm" onclick="rechazarSolicitud('${solicitud._id}')" style="background: linear-gradient(135deg, #dc3545, #c82333); padding: 5px 10px; font-size: 0.8em;">Rechazar</button>
            </div>
          </div>
        `;
        listaSolicitudesMensajesEl.appendChild(li);
      });
    } catch (error) {
      console.error('Error loading message requests:', error);
      if(listaSolicitudesMensajesEl) listaSolicitudesMensajesEl.innerHTML = '<li style="text-align:center; color:red;">Error al cargar solicitudes.</li>';
    }
   }

   async function aprobarSolicitud(solicitudId) {
    if (!app.user) return;
    try {
      utils.showUpdateIndicator();
      const resultado = await utils.apiCall(`/solicitudesMensajes/${solicitudId}/aprobar`, { method: 'PUT' });
      utils.showMessage(resultado.mensaje || 'Solicitud aprobada.', 'success');
      await cargarSolicitudesMensajes(); // Refresh requests list
      await chat.loadConversations();   // Refresh conversations list
      // Optionally, open chat with the user
      if (resultado.mensajeCreado && resultado.mensajeCreado.emisor) { // emisor of message is original sender of request
         // The message is created from the perspective of the original sender.
         // So, if current user (receptor of request) approves it, the 'other user' in chat is `mensajeCreado.emisor`
         chat.openChat(resultado.mensajeCreado.emisor._id, resultado.mensajeCreado.emisor.nombre);
      } else if (resultado.solicitud && resultado.solicitud.emisor){ // Fallback if mensajeCreado is not fully populated as expected
         const solicitudOriginal = await utils.apiCall(`/solicitudesMensajes`); // Fetch again to get populated emisor if needed
         const solicitudAprobada = solicitudOriginal.find(s => s._id === solicitudId); // This is not ideal, API should return populated data
         if(solicitudAprobada && solicitudAprobada.emisor) { // Check if emisor exists on the approved request object
            chat.openChat(solicitudAprobada.emisor._id, solicitudAprobada.emisor.nombre);
         } else {
            // Fallback: find the request in the list to get emisor info (less ideal)
            const solicitudElement = Array.from(listaSolicitudesMensajesEl.children).find(li => li.innerHTML.includes(solicitudId));
            if (solicitudElement) {
                // This is tricky as name is in HTML. Better to rely on API response.
                // For now, just log it. A better solution would be ensuring API returns necessary info.
                console.log("Solicitud aprobada, pero no se pudo abrir el chat automáticamente por falta de datos del emisor.");
            }
         }
      }
    } catch (error) {
      console.error('Error approving request:', error);
      // utils.showMessage will be called by apiCall
    }
   }

   async function rechazarSolicitud(solicitudId) {
    if (!app.user) return;
    try {
      utils.showUpdateIndicator();
      const resultado = await utils.apiCall(`/solicitudesMensajes/${solicitudId}/rechazar`, { method: 'PUT' });
      utils.showMessage(resultado.mensaje || 'Solicitud rechazada.', 'success');
      await cargarSolicitudesMensajes(); // Refresh requests list
    } catch (error) {
      console.error('Error rejecting request:', error);
      // utils.showMessage will be called by apiCall
    }
   }

   // [FROM HOME.HTML, with minor adaptations if needed] Full 'chat' object:
   const chat = {
     async loadConversations() {
       if (!app.user || !listaConversacionesEl) return;
       try {
         utils.showUpdateIndicator();
         const conversations = await utils.apiCall('/mensajes/conversaciones');
         listaConversacionesEl.innerHTML = ''; 
         if (conversations.length === 0) {
           listaConversacionesEl.innerHTML = '<li style="text-align:center; color:#888e9e !important; font-style: italic !important; padding: 25px !important; background: transparent !important; border: none !important;">No tienes conversaciones activas.</li>';
           return;
         }
         conversations.forEach(conv => {
           const li = document.createElement('li');
           li.style.cursor = 'pointer';
           // Wrap user info and last message in a div to better control layout with the button
           li.innerHTML = `
             <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                <div style="flex-grow: 1; display: flex; align-items: center;">
                    <div style="flex-grow: 1; cursor: pointer;" onclick="chat.openChat('${conv.otroUsuario._id}', '${conv.otroUsuario.nombre.replace(/'/g, "\\'")}')">
                        <strong style="color: #e0e6ed;">${conv.otroUsuario.nombre}</strong>
                        <small style="display:block; color: #9ca3af; font-size:0.8em;">
                          ${conv.esEmisor ? 'Tú: ' : ''}${conv.ultimoMensaje.substring(0, 20)}${conv.ultimoMensaje.length > 20 ? '...' : ''}
                        </small>
                    </div>
                    <button class="btn btn-sm archive-chat-btn" data-user-id="${conv.otroUsuario._id}" style="background: #dc3545; padding: 3px 8px; font-size: 0.7em; margin-left: 10px; flex-shrink: 0;">X</button>
                </div>
                <small style="color: #9ca3af; font-size:0.75em; flex-shrink: 0; margin-left: 5px;">${new Date(conv.fechaEnvio).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</small>
             </div>
           `;
           // It's generally better to attach event listeners using JS rather than inline onclick for the main chat opening action as well.
           // However, to minimize changes to existing structure, the div for opening chat now has an onclick.
           // The archive button will have its listener attached separately in a later step.
           li.dataset.userId = conv.otroUsuario._id; // Keep this if other parts of the code use it directly on the li
           li.dataset.userName = conv.otroUsuario.nombre;
           // The main click to open chat is now on the inner div.
           // If you need the li itself to be clickable for other reasons, you might need to adjust.
           // For now, removing the direct li.onclick to avoid conflict with button click if not handled carefully.
           // li.onclick = () => this.openChat(conv.otroUsuario._id, conv.otroUsuario.nombre); 
           listaConversacionesEl.appendChild(li);
         });
       } catch (error) {
         console.error('Error loading conversations:', error);
         // utils.showMessage('Error al cargar conversaciones', 'error'); // Already handled by apiCall
         if(listaConversacionesEl) listaConversacionesEl.innerHTML = '<li style="text-align:center; color:red;">Error al cargar conversaciones.</li>';
       }
     },

     async openChat(userId, userName) {
       if (!app.user) {
         utils.showMessage('Debes iniciar sesión para chatear.', 'error');
         return;
       }
       app.currentChatPartnerId = userId;
       app.currentChatPartnerName = userName;

       if(chatUserNameEl) chatUserNameEl.textContent = userName;
       if(chatPanelEl) chatPanelEl.style.display = 'block';
       
       // app.currentChatArchivalStatus = null; // Obsolete

       // Enable inputs and clear previous status messages by default
       if(chatMessageInputEl) chatMessageInputEl.disabled = false;
       if(sendChatMessageBtnEl) sendChatMessageBtnEl.disabled = false;
       const inputArea = document.querySelector('.chat-input-area');
       if(inputArea) inputArea.style.display = 'flex'; 

       if(chatMessagesEl) { 
           const existingStatusElements = chatMessagesEl.querySelectorAll('.chat-status-message, .archival-actions-bar');
           existingStatusElements.forEach(el => el.remove());
           const placeholder = chatMessagesEl.querySelector('p[style*="text-align:center"]');
           if(placeholder) placeholder.remove(); // Clear "Cargando mensajes..." or "No hay mensajes..."
           chatMessagesEl.innerHTML = '<p style="text-align:center; color:#888e9e !important; font-style: italic !important; padding: 25px !important;">Cargando mensajes...</p>'; // Set loading message
       } else if (chatPlaceholderEl) { // Fallback if chatMessagesEl isn't ready (should be)
           chatPlaceholderEl.style.display = 'none';
       }


       await this.loadMessages(); // This will now handle UI based on archival status
       this.startPollingMessages();
       if(chatMessageInputEl && !chatMessageInputEl.disabled) chatMessageInputEl.focus(); // Focus only if not disabled
       history.pushState(null, '', `mensajes.html?chatWith=${userId}&chatWithNombre=${encodeURIComponent(userName)}`);
     },

     async loadMessages(isPolling = false) {
        if (!app.currentChatPartnerId || !app.user || !chatMessagesEl) return;

        let messages = [];
        // Default status, including new chatPrivilegioId
        let chatStatus = { 
            isHidden: false, 
            chatPrivilegioEstado: 'none', 
            showPendingActionNotification: false,
            showReactivationPendingNotification: false,
            initiatorName: null,
            allowMessageSending: true,
            chatPrivilegioId: null 
        };
        
        try {
            const response = await utils.apiCall(`/mensajes/conversacion/${app.user._id}/${app.currentChatPartnerId}`);
            messages = response.messages || [];
            chatStatus = response.chatStatus || chatStatus; // Use server status or default
            
            app.currentChatPrivilegioId = chatStatus.chatPrivilegioId; // Store for use in requestReactivation

            chatMessagesEl.innerHTML = ''; // Clear previous messages
            const existingStatusElements = chatMessagesEl.querySelectorAll('.chat-status-message, .chat-action-buttons');
            existingStatusElements.forEach(el => el.remove()); // Clear old custom UI

            if (messages && messages.length > 0) {
                messages.forEach(msg => this.renderMessage(msg));
            } else {
                // Only show "No hay mensajes" if no other status notification is shown
                if (!chatStatus.showPendingActionNotification && !chatStatus.showReactivationPendingNotification) {
                    chatMessagesEl.innerHTML = '<p style="text-align:center; color:#888e9e !important; font-style: italic !important; padding: 25px !important;">No hay mensajes. ¡Envía el primero!</p>';
                }
            }
            
            // Handle UI based on chatStatus
            if (chatStatus.showPendingActionNotification) {
                chatMessageInputEl.disabled = true;
                sendChatMessageBtnEl.disabled = true;
                
                const notificationP = document.createElement('p');
                notificationP.className = 'chat-status-message';
                notificationP.innerHTML = `${chatStatus.initiatorName || 'El otro usuario'} ha ocultado esta conversación.`;
                notificationP.style.textAlign = 'center'; 
                notificationP.style.fontStyle = 'italic'; 
                notificationP.style.margin = '10px 0';
                chatMessagesEl.appendChild(notificationP); // Append below messages

                const buttonsDiv = document.createElement('div');
                buttonsDiv.className = 'chat-action-buttons';
                buttonsDiv.style.textAlign = 'center';
                buttonsDiv.style.margin = '10px 0';
                // app.currentChatPartnerId here is User A (initiatorOfHide)
                buttonsDiv.innerHTML = `
                    <button id="confirmDeleteBtn" class="btn btn-danger btn-sm">Eliminar este chat</button>
                `;
                chatMessagesEl.appendChild(buttonsDiv); // Append below notification

                // Event listener for the delete button
                if(document.getElementById('confirmDeleteBtn')) document.getElementById('confirmDeleteBtn').onclick = () => chat.confirmDeleteSharedChat(app.currentChatPartnerId); 
                // Removed event listener for requestReactivateBtn as the button is removed

            } else if (chatStatus.showReactivationPendingNotification) {
                chatMessageInputEl.disabled = true;
                sendChatMessageBtnEl.disabled = true;
                const notificationP = document.createElement('p');
                notificationP.className = 'chat-status-message';
                notificationP.innerHTML = `Solicitud de reactivación enviada a ${chatStatus.initiatorName || 'El otro usuario'}. Esperando respuesta.`;
                notificationP.style.textAlign = 'center'; 
                notificationP.style.fontStyle = 'italic'; 
                notificationP.style.margin = '10px 0';
                chatMessagesEl.appendChild(notificationP); // Append below messages
            }
            else if (!chatStatus.allowMessageSending) { 
                // General case if server dictates messages cannot be sent, and no specific notification shown above
                chatMessageInputEl.disabled = true;
                sendChatMessageBtnEl.disabled = true;
                // Optionally, add a generic "No puedes enviar mensajes en este momento" if not covered by other states.
            } else {
              chatMessageInputEl.disabled = false;
              sendChatMessageBtnEl.disabled = false;
            }
            
            chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;

        } catch (error) {
            console.error('Error loading messages:', error);
            if (!isPolling && chatMessagesEl) {
                chatMessagesEl.innerHTML = '<p style="text-align:center; color:red;">Error al cargar mensajes. Intenta de nuevo.</p>';
            }
        }
     },

     renderMessage(msg) {
       const msgDiv = document.createElement('div');
       const isCurrentUser = msg.emisor._id === app.user._id;
       msgDiv.className = 'chat-message ' + (isCurrentUser ? 'sent' : 'received');
       const processedContent = msg.contenido.replace(/\n/g, '<br>');
       msgDiv.innerHTML = `
         <div class="chat-message-bubble">
           <span class="message-sender">${msg.emisor.nombre}</span>
           <div class="message-content">${processedContent}</div>
           <span class="message-timestamp">${new Date(msg.fechaEnvio).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</span>
         </div>`;
       chatMessagesEl.appendChild(msgDiv);
     },

     async sendMessage() {
       if(!chatMessageInputEl || !app.currentChatPartnerId || !app.user) return;
       const content = chatMessageInputEl.value.trim();
       if (!content) return;

       // Prevent sending messages to self
       if (app.user._id === app.currentChatPartnerId) {
         utils.showMessage('No puedes enviarte mensajes a ti mismo.', 'warning');
         return;
       }

       try {
         const response = await utils.apiCall('/mensajes', { // This call now returns {type, data} or error
           method: 'POST',
           body: JSON.stringify({
             emisor: app.user._id,
             receptor: app.currentChatPartnerId,
             contenido: content
           })
         });

         chatMessageInputEl.value = ''; // Clear input field regardless of outcome type

         if (response && response.type === 'mensaje') {
           // Message sent directly because chat is active
           const placeholder = chatMessagesEl.querySelector('p[style*="text-align:center"]');
           if (placeholder) placeholder.remove();
           
           this.renderMessage(response.data); // Render the message for the sender
           chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight; // Scroll to new message
           // utils.showMessage('Mensaje enviado.', 'success'); 
         } else if (response && response.type === 'solicitud') {
           utils.showMessage('Solicitud de mensaje enviada.', 'info');
         } else if (response && response.type === 'solicitud_existente') {
            // Backend indicated a request already exists (based on our custom type in POST /mensajes)
            utils.showMessage('Ya tienes una solicitud pendiente con este usuario.', 'warning');
         } else {
            // Fallback for unexpected response structure, though apiCall should throw for HTTP errors.
            utils.showMessage('Respuesta inesperada del servidor.', 'error');
         }
         
         // Refresh conversations list, might show updated last message or status
         await this.loadConversations();

       } catch (error) {
         // apiCall already logs the error. utils.showMessage might be called by apiCall for generic errors.
         // Specific error handling based on error.message or a status code from error object if needed.
         // For example, if apiCall is modified to throw structured errors:
         if (error.message && error.message.includes('409')) { // Assuming 409 is for conflict/pending request
            utils.showMessage('Ya tienes una solicitud pendiente con este usuario.', 'warning');
         } else if (error.message && error.message.includes('400') || error.message.includes('404')) {
            // Handled by apiCall's default error message, or add specific ones.
            // utils.showMessage('Error en los datos enviados.', 'error');
         } else {
            // General error message shown by apiCall or a fallback here
            // utils.showMessage('Error al enviar mensaje/solicitud.', 'error');
         }
         // The console.error is good for debugging
         console.error('Error en chat.sendMessage:', error);
       }
     },

     startPollingMessages() {
       this.stopPollingMessages(); 
       if (app.currentChatPartnerId) {
         app.chatPollInterval = setInterval(() => {
            if (document.visibilityState === 'visible' && app.currentChatPartnerId && app.user) {
                this.loadMessages(true);
            }
         }, 5000); 
       }
     },

     stopPollingMessages() {
       if (app.chatPollInterval) {
         clearInterval(app.chatPollInterval);
         app.chatPollInterval = null;
       }
     },

     startPollingSolicitudes() {
       this.stopPollingSolicitudes(); 
       if (app.user) { // Only poll if user is logged in
         app.solicitudesPollInterval = setInterval(() => {
           if (document.visibilityState === 'visible' && app.user) { // Check visibility and user again inside interval
               cargarSolicitudesMensajes(true); // Pass true for silent update
           }
         }, 15000); // Poll every 15 seconds (adjust as needed)
       }
     },

     stopPollingSolicitudes() {
       if (app.solicitudesPollInterval) {
         clearInterval(app.solicitudesPollInterval);
         app.solicitudesPollInterval = null;
       }
     },

     async hideConversation(partnerUserId) { // Renamed from archiveConversation
        if (!app.user || !partnerUserId) return;
        try {
          utils.showUpdateIndicator(); 
          await utils.apiCall(`/mensajes/conversacion/${partnerUserId}/hide`, { // New endpoint
            method: 'POST',
          });
          utils.showMessage('Conversación oculta.', 'success'); // Updated message
      
          await this.loadConversations(); // Refresh conversation list
      
          // If the hidden conversation was currently open, reset the chat panel
          if (app.currentChatPartnerId === partnerUserId) {
              chatPanelEl.style.display = 'none'; 
              app.currentChatPartnerId = null;
              app.currentChatPartnerName = null;
              chat.stopPollingMessages();
              
              // Reset to placeholder view
              if (chatPlaceholderEl && chatPanelEl) {
                  chatPanelEl.style.display = 'block';
                  chatMessagesEl.innerHTML = '';
                  if (chatUserNameEl) chatUserNameEl.textContent = 'Usuario';
                  chatPlaceholderEl.style.display = 'block';
                  chatPlaceholderEl.innerHTML = 'Selecciona una conversación de la lista para empezar a chatear.';
                  const inputArea = document.querySelector('.chat-input-area');
                  if (inputArea) inputArea.style.display = 'none';
                  history.pushState(null, '', 'mensajes.html');
              }
          }
        } catch (error) {
          console.error('Error al ocultar la conversación:', error); // Updated error message
          // utils.apiCall should handle showing a generic error message.
        }
      },

      // displayArchivedByMeMessage, displayArchivedByOtherUserMessageAndActions, 
      // acknowledgeArchive, and requestReopenChat are REMOVED as they are obsolete.

      async confirmDeleteSharedChat(partnerIdWhoInitiatedHide) {
        if (!partnerIdWhoInitiatedHide) return;
  
        // Optional: Client-side confirmation dialog
        // if (!confirm('¿Estás seguro de que quieres eliminar este chat permanentemente? Esta acción no se puede deshacer.')) {
        //   return;
        // }
  
        try {
          utils.showUpdateIndicator();
          const response = await utils.apiCall(`/mensajes/conversacion/${partnerIdWhoInitiatedHide}/confirm-delete`, {
            method: 'POST',
          });
          
          utils.showMessage(response.message || 'Chat eliminado permanentemente.', 'success');
          
          await this.loadConversations(); // Refresh conversation list
          
          if (app.currentChatPartnerId === partnerIdWhoInitiatedHide) {
              chatPanelEl.style.display = 'none'; 
              app.currentChatPartnerId = null;
              app.currentChatPartnerName = null;
              chat.stopPollingMessages();

              if (chatPlaceholderEl && chatPanelEl) {
                  chatPanelEl.style.display = 'block';
                  chatMessagesEl.innerHTML = '';
                  if (chatUserNameEl) chatUserNameEl.textContent = 'Usuario';
                  chatPlaceholderEl.style.display = 'block';
                  chatPlaceholderEl.innerHTML = 'Selecciona una conversación de la lista para empezar a chatear.';
                  const inputArea = document.querySelector('.chat-input-area');
                  if (inputArea) inputArea.style.display = 'none';
                  history.pushState(null, '', 'mensajes.html');
              }
          }
        } catch (error) {
          console.error('Error al confirmar la eliminación del chat:', error);
          // utils.showMessage is likely called by apiCall for generic errors
        }
      }
      // chat.requestReactivation, chat.acceptReactivation, chat.rejectReactivation are REMOVED
   };

   // async function cargarSolicitudesReactivacion() { ... } is REMOVED

   // Refined init() function for mensajes.html
   async function init() {
     homeBtnEl = document.getElementById('homeBtn');
     profileBtnEl = document.getElementById('profileBtn');
     logoutBtnEl = document.getElementById('logoutBtn');
     logoutModal = document.getElementById('logoutModal');
     confirmLogoutBtn = document.getElementById('confirmLogoutBtn');
     cancelLogoutBtn = document.getElementById('cancelLogoutBtn');
     updateIndicator = document.getElementById('updateIndicator');

     // Archive modal related DOM element lookups are removed.

     listaConversacionesEl = document.getElementById('listaConversaciones');
     chatPanelEl = document.getElementById('chatPanel');
     chatUserNameEl = document.getElementById('chatUserName');
     chatMessagesEl = document.getElementById('chatMessages');
     chatMessageInputEl = document.getElementById('chatMessageInput');
     sendChatMessageBtnEl = document.getElementById('sendChatMessageBtn');
     chatPlaceholderEl = document.getElementById('chatPlaceholder');
     listaSolicitudesMensajesEl = document.getElementById('listaSolicitudesMensajes');
     // listaSolicitudesReactivacionEl related lines are fully removed.

     if (!(await auth.checkSession())) return; 
     
     await cargarSolicitudesMensajes(); 
     // await cargarSolicitudesReactivacion(); // Fully removed call.

     if(homeBtnEl) homeBtnEl.onclick = () => window.location.href = 'home.html';
     if(profileBtnEl && app.user) profileBtnEl.onclick = () => window.location.href = `perfil.html?id=${app.user._id}`;
     else if(profileBtnEl) profileBtnEl.style.display = 'none'; 
     
     if(logoutBtnEl) logoutBtnEl.onclick = () => { if(logoutModal) logoutModal.style.display = 'block'; };
     if(confirmLogoutBtn) confirmLogoutBtn.onclick = () => { auth.logout(); if(logoutModal) logoutModal.style.display = 'none'; };
     if(cancelLogoutBtn) cancelLogoutBtn.onclick = () => { if(logoutModal) logoutModal.style.display = 'none'; };

     // Event listener for dynamically added hide buttons (formerly archive buttons)
     if (listaConversacionesEl) {
        listaConversacionesEl.addEventListener('click', function(event) {
            const hideButton = event.target.closest('.archive-chat-btn'); // Still using .archive-chat-btn class
            if (hideButton) {
                event.stopPropagation(); 
                const partnerId = hideButton.dataset.userId;
                if (partnerId) {
                    // Optional: Add a confirm dialog if immediate hide is too abrupt
                    // if (confirm('¿Seguro que quieres ocultar esta conversación?')) {
                    //    chat.hideConversation(partnerId);
                    // }
                    // For now, implementing as immediate hide:
                    chat.hideConversation(partnerId);
                }
            }
        });
     }

     // Event listeners for archive modal buttons are removed

     if (sendChatMessageBtnEl) {
       sendChatMessageBtnEl.onclick = () => chat.sendMessage();
     }
     if (chatMessageInputEl) {
       chatMessageInputEl.addEventListener('keypress', (e) => {
         if (e.key === 'Enter' && !e.shiftKey) {
           e.preventDefault();
           chat.sendMessage();
         }
       });
     }

     await chat.loadConversations();

     const urlParams = new URLSearchParams(window.location.search);
     const chatWithUserId = urlParams.get('chatWith');
     const chatWithUserName = urlParams.get('chatWithNombre'); // Already URL decoded by get()
     
     if (chatWithUserId) {
       // Use decodeURIComponent for chatWithUserName just in case it wasn't fully handled or contains special chars
       const resolvedUserName = chatWithUserName ? decodeURIComponent(chatWithUserName) : 'Usuario'; 
       await chat.openChat(chatWithUserId, resolvedUserName); 
     } else {
        if (!app.currentChatPartnerId && chatPlaceholderEl && chatPanelEl) {
            chatPanelEl.style.display = 'block'; 
            chatMessagesEl.innerHTML = ''; 
            chatPlaceholderEl.style.display = 'block';
            chatPlaceholderEl.innerHTML = 'Selecciona una conversación de la lista para empezar a chatear.'; // Use innerHTML for styled placeholders
            const inputArea = document.querySelector('.chat-input-area');
            if(inputArea) inputArea.style.display = 'none';
        }
     }
     
     // Initial state of chat input area based on whether a chat is open
     const inputArea = document.querySelector('.chat-input-area');
     if(inputArea){
        inputArea.style.display = app.currentChatPartnerId ? 'flex' : 'none';
     }


     document.addEventListener('visibilitychange', () => {
       if (document.hidden) {
         chat.stopPollingMessages();
         chat.stopPollingSolicitudes(); // Ensure this is present
       } else {
         if(app.user) { 
            chat.loadConversations(); 
            if (app.currentChatPartnerId) { 
              chat.loadMessages(false); 
              chat.startPollingMessages();
            }
            cargarSolicitudesMensajes(false); // Immediate non-silent load for requests
            chat.startPollingSolicitudes();   // Restart silent polling for requests
         } else { // If no user session (e.g., session expired and tab refocused)
            auth.checkSession(); // Optionally re-check session
         }
       }
     });

     chat.startPollingSolicitudes(); 
   }

    window.onclick = function(event) {
      if (event.target == logoutModal) {
        logoutModal.style.display = "none";
      }
      // window.onclick no longer needs to handle archiveChatModal
    }

    init();
  </script>
  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/toastify-js"></script>
  <script type="text/javascript" src="notifications.js"></script> <!-- Assuming notifications.js exists for showNotification -->
</body>
</html>